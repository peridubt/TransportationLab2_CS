namespace TransportationLab2
{
    #region Общее описание задания
    /*
    Задание 2
    Цель — создание модели, описывающей процесс, построение иерархии классов,
    отражающей данную предметную область.
    
    По действиям пользователя
    следует создавать экземпляры классов иерархии. Использовать исключения. 

    Разработать класс менеджера, позволяющего создавать, 
    уничтожать и модифицировать объекты (в некоторых задачах — динамика от таймера).

    Для каждой задачи необходимо реализовать объектную модель. 
    В реализации задач должны присутствовать наследование, агрегация и др.
    взаимодействия классов.
    
    Интерфейс к задаче необходимо выполнить на
    WinForms с использованием компонентов. Для отображения использовать
    2D-графику или графические элементы управления. 
    
    Формы и компоненты используются только для отображения и ввода данных, 
    но не для хранения объектов. Использовать исключения (exceptions).
    */
    #endregion

    #region Требования
    /*
    Требования к реализации.
     Приложение реализовать как MVC. Модель — иерархия классов.
    View — демо в автоматическом режиме.
     Действующие объекты должны быть реализованы как 
    потоки с необходимой синхронизацией.
     Для оповещения об изменениях использовать 
    шаблон «Наблюдатель».
     Для создания действующих объектов 
    использовать шаблон «Фабрика».
     Использование других шаблонов приветствуется.*/
    #endregion

    #region Условие
    /*
    10. Грузоперевозки. Основные сущности: автомашины, города,
    между которыми осуществляются перевозки, сеть дорог, грузы,
    их типы, клиенты. Смоделировать процесс перевозки грузов.
    */
    #endregion

    #region Моя идея логики работы лабы
    /*
    1. Автомашины - тут всё просто: есть интерфейс автомашины и класс, который его реализует.
    Его полями пусть будут марка машины, регистрационный номер, грузоподъёмность, грузы, которые туда поместили,
    точка назначения
    2. Города - схема та же самая: полями будут названия (мб что-то ещё)
    3. Дороги - всё так же: поля - это город отправки и город доставки, а также протяжённость.
    Засчёт протяжённости будет меняться время доставки (сколько поток будет "спать" + длительность анимации)
    4. Грузы и их типы - самое интересное.
    Здесь как раз и реализуется паттерн "Фабрика", потому что типов может быть несколько.
    Будет интерфейс для типа груза (в папке Unit), а также интерфейс для билдера (в папке Fabric).
    Дальше понтяно, что согласно данному патерну нужно будет создать отдельные классы, которые 
    выражают сам тип груза, а также те, которые их соответсвующе порождают (те самые билдеры).
    Пример: есть интерфейс ICargoType и для него ICargoTypeBuilder, потом конкретные классы пошли:
    Fragile (и FragileBuilder), Heavy (и HeavyBuilder) и т.д. ...
    Насчёт полей: будет определено название груза, его вес, стоимость доставки, куда доставляют, сведения о клиенте и т.д. 
    5. Клиенты - здесь всё просто: ФИО, город, что получает, сколько платит за доставку (продумать точно)
    
    
    Насчёт паттерна наблюдатель пока не совсем понятно. Известно, что данный шаблон реализует связь
    "один-ко-многим", т.е. при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.
    Предполагаю, что нужен будет отдельный класс с названием типа Message (класс для уведомлений), 
    который будет уведомлять нашего клиента (это наблюдатель, реализует IObserver<Message>)
    при успешной доставке груза (наблюдаемый объект, или же IObservable<Message>).
    
    Только непонятно, зачем тут этот шаблон, если мы уведомляем одного наблюдателя?
    Если же он тут нужен, то откуда возьмутся ещё наблюдатели? Несколько клиентов принимают груз? Непонтяно.
    
    Ещё есть такой прикол, что паттерн на .NET наблюдателя можно реализовать с помощью событийной модели, 
    однако рекомендуют использовать простую реализацию на классах, чтобы можно было это воплотить 
    на любом другом языке (т.к. события на шарпах - это местный сахар, который не везде есть)
    */
    #endregion
    internal static class Program
    {
        [STAThread]
        static void Main()
        {
            ApplicationConfiguration.Initialize();
            Application.Run(new Form1());
        }
    }
}